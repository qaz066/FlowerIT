# -*- coding: utf-8 -*-
"""infer.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12ZwA0xsOqlpSGByInDxu9wyVZph1AdnI
"""

# ============ Colab: 기본 설정 & 경로 ============
from google.colab import drive
drive.mount('/content/drive')

# ★ 경로만 내 환경에 맞게 수정 ★
#MODEL_PATH = "/content/drive/MyDrive/TS/ResNet50.keras"  # .keras 모델 경로
MODEL_PATH = "/content/drive/MyDrive/TS/EfficientNetB3.keras"
LABELS_JSON = "/content/drive/MyDrive/TS/dataset/labels.json"      # train_generator.class_indices 저장본(있으면 강추)
IMG_LIST = [
    "/content/drive/MyDrive/TS/image/image1.jpg",
    "/content/drive/MyDrive/TS/image/image2.jpg",
]  # 분류해볼 이미지 경로들
TOPK = 1

# ============ 모델 로드 ============
import tensorflow as tf, json, os, numpy as np
import matplotlib.pyplot as plt
from PIL import Image

# .keras 로드(compile 불필요)
model = tf.keras.models.load_model(MODEL_PATH, compile=False)
print("✓ model loaded:", MODEL_PATH)
print("input_shape:", model.input_shape)

# 입력 크기 자동 추출
H, W = model.input_shape[1], model.input_shape[2]
assert H is not None and W is not None, "모델 input_shape가 고정이어야 합니다."

# 라벨 이름 로드: labels.json이 있으면 가장 안전
class_names = None
if os.path.exists(LABELS_JSON):
    with open(LABELS_JSON, "r", encoding="utf-8") as f:
        ci = json.load(f)  # 예: {'healthy':0,'sick':1,...}
    # index -> name으로 정렬
    inv = {v:k for k,v in ci.items()}
    class_names = [inv[i] for i in range(len(inv))]
    print("✓ labels loaded:", class_names)
else:
    # 없으면 임시로 index 기반 이름
    num_classes = model.output_shape[-1]
    class_names = [f"class_{i}" for i in range(num_classes)]
    print("! labels.json 없음 → 임시 라벨:", class_names)

# ============ 전처리 & 예측 유틸 ============

import numpy as np
from PIL import Image

# 예: EfficientNetB3라면 (300, 300). ResNet50이면 (224, 224)
IMG_SIZE = (300, 300)  # (H, W) 형식으로 적되, 아래에서 (W,H)로 뒤집어 사용함
TO_MINUS1 = True       # 학습 때 [-1,1] 스케일을 썼다면 True
CENTER_ZOOM_KEEP = None
# 예) 학습 때 80% 확대를 썼으면:
# CENTER_ZOOM_KEEP = 1/1.8  # ≈0.555

def _center_crop_np(arr_hw3, keep: float):
    H, W = arr_hw3.shape[:2]
    ch, cw = int(round(H * keep)), int(round(W * keep))
    y0 = (H - ch) // 2
    x0 = (W - cw) // 2
    return arr_hw3[y0:y0+ch, x0:x0+cw, :]

def load_and_preprocess(path, size=IMG_SIZE, to_minus1=TO_MINUS1, center_zoom_keep=CENTER_ZOOM_KEEP):
    # 1) 로드 + 리사이즈 (PIL은 (width, height) 순서!)
    H, W = size
    img = Image.open(path).convert("RGB").resize((W, H), Image.BILINEAR)

    # 2) [0,1] 스케일
    arr = np.asarray(img, dtype=np.float32) / 255.0  # (H,W,3)

    # 3) (옵션) 중앙 고정 확대 (학습과 같은 처리 원할 때)
    if center_zoom_keep is not None:
        arr = _center_crop_np(arr, center_zoom_keep)
        # crop 후 다시 원하는 입력 크기로 리사이즈
        arr = np.array(Image.fromarray((arr * 255).astype(np.uint8)).resize((W, H), Image.BILINEAR), dtype=np.float32) / 255.0

    # 4) [-1,1] 스케일 (EfficientNet류를 훈련 때 이렇게 맞췄다면)
    if to_minus1:
        arr = arr * 2.0 - 1.0

    # 5) 배치 차원 추가
    arr = np.expand_dims(arr, axis=0)  # (1,H,W,3)
    return img, arr  # img: PIL 이미지(디스플레이용), arr: 모델 입력

def predict_topk(arr, model, topk=3, class_names=None):
    logits_or_probs = model.predict(arr, verbose=0)[0]  # (C,)

    # 확률화(안전 처리)
    probs = logits_or_probs.astype(np.float64)
    # 이미 softmax된 확률일 수도 있지만, 수치 오차 대비하여 정규화
    if (probs.min() < 0) or (probs.max() > 1.0 + 1e-3) or (abs(probs.sum() - 1.0) > 1e-2):
        # logits로 간주하고 softmax
        e = np.exp(probs - np.max(probs))
        probs = e / e.sum()

    # 안전한 Top-K (argpartition → 정렬)
    k = min(topk, probs.shape[0])
    top_idx = np.argpartition(probs, -k)[-k:]
    top_idx = top_idx[np.argsort(probs[top_idx])[::-1]]
    top_probs = probs[top_idx]

    if class_names is not None:
        top_labels = [class_names[i] for i in top_idx]
    else:
        top_labels = [int(i) for i in top_idx]

    return probs, list(zip(top_idx, top_labels, top_probs))

# ============ 이미지 몇 장 예측 & 시각화 ============
import os
import matplotlib.pyplot as plt

ncols = 2
nrows = (len(IMG_LIST) + ncols - 1) // ncols
plt.figure(figsize=(5*ncols, 5*nrows))

for i, p in enumerate(IMG_LIST, start=1):
    # 1) 로드 & 전처리
    img, arr = load_and_preprocess(p)  # (PIL.Image, (1,H,W,3) ndarray)

    # 2) 예측 (predict_topk는 (probs, [(idx, label, prob), ...]) 반환)
    probs, top = predict_topk(arr, model, topk=TOPK, class_names=class_names)

    # 3) 제목 만들기: 파일명 + Top-K 결과
    title_lines = [os.path.basename(p)]
    for (cls_idx, cls_label, cls_prob) in top:
        title_lines.append(f"{cls_label}: {cls_prob*100:.2f}%")
    title = "\n".join(title_lines)

    # 4) 시각화
    ax = plt.subplot(nrows, ncols, i)
    ax.imshow(img)
    ax.axis("off")
    ax.set_title(title, fontsize=12)

plt.tight_layout()
plt.show()